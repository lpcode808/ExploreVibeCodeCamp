<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibe Code Camp RPG</title>
    <link rel="icon" type="image/svg+xml" href="../favicon-terminal.svg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #game-canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 4px solid #4a4a6a;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hidden {
            display: none !important;
        }

        /* Title Screen */
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #1a1a2e 0%, #2d2d4a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fcfcfc;
            text-align: center;
            z-index: 100;
        }

        #title-screen h1 {
            font-size: 32px;
            color: #f8a848;
            text-shadow: 3px 3px 0 #202020;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        #title-screen h2 {
            font-size: 18px;
            color: #7ec850;
            text-shadow: 2px 2px 0 #202020;
            margin-bottom: 40px;
        }

        #title-screen .prompt {
            font-size: 16px;
            animation: blink 1s infinite;
        }

        #title-screen .controls {
            margin-top: 30px;
            font-size: 12px;
            color: #aaa;
            line-height: 1.8;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Dialogue Box */
        #dialogue-box {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(20, 20, 40, 0.95);
            border: 3px solid #fcfcfc;
            border-radius: 4px;
            padding: 12px;
            color: #fcfcfc;
            z-index: 50;
            pointer-events: auto;
        }

        #dialogue-speaker {
            font-size: 14px;
            color: #f8a848;
            margin-bottom: 8px;
            font-weight: bold;
        }

        #dialogue-link {
            display: inline-block;
            font-size: 12px;
            color: #8fd3ff;
            text-decoration: underline;
            margin-bottom: 8px;
        }

        #dialogue-link:hover {
            color: #f8a848;
        }

        #dialogue-text {
            font-size: 14px;
            line-height: 1.5;
            min-height: 42px;
        }

        #dialogue-prompt {
            text-align: right;
            font-size: 12px;
            color: #aaa;
            margin-top: 8px;
            animation: blink 1s infinite;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: #fcfcfc;
            font-size: 14px;
            text-shadow: 2px 2px 0 #202020;
            z-index: 40;
        }

        #world-name {
            background: rgba(20, 20, 40, 0.8);
            padding: 6px 12px;
            border-radius: 4px;
            border: 2px solid #a080d0;
        }

        #insight-counter {
            background: rgba(20, 20, 40, 0.8);
            padding: 6px 12px;
            border-radius: 4px;
            border: 2px solid #f8a848;
        }

        #journal-hint {
            background: rgba(20, 20, 40, 0.8);
            padding: 6px 12px;
            border-radius: 4px;
            border: 2px solid #7ec850;
        }

        #sound-toggle {
            background: rgba(20, 20, 40, 0.8);
            padding: 6px 12px;
            border-radius: 4px;
            border: 2px solid #5b8cbe;
            cursor: pointer;
            pointer-events: auto;
            transition: opacity 0.2s;
        }

        #sound-toggle:hover {
            opacity: 0.8;
        }

        #sound-toggle.muted {
            border-color: #666;
            color: #666;
        }

        #zoom-hint {
            background: rgba(20, 20, 40, 0.8);
            padding: 6px 12px;
            border-radius: 4px;
            border: 2px solid #e05038;
        }

        .hud-left {
            display: flex;
            gap: 8px;
        }

        .hud-right {
            display: flex;
            gap: 8px;
        }

        /* World Inventory */
        #world-inventory {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            background: rgba(20, 20, 40, 0.9);
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid #4a4a6a;
            z-index: 40;
        }

        .inventory-world {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: default;
            opacity: 0.4;
            transition: opacity 0.2s, transform 0.2s;
        }

        .inventory-world.has-insights {
            opacity: 0.7;
        }

        .inventory-world.complete {
            opacity: 1;
        }

        .inventory-world.current {
            transform: scale(1.1);
            opacity: 1;
        }

        .inventory-world canvas {
            image-rendering: pixelated;
        }

        .inventory-world .count {
            font-size: 9px;
            color: #aaa;
        }

        .inventory-world.complete .count {
            color: #7ec850;
        }

        /* Journal */
        #journal-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 20, 40, 0.98);
            color: #fcfcfc;
            z-index: 80;
            overflow-y: auto;
            padding: 20px;
            pointer-events: auto;
        }

        #journal-screen h2 {
            text-align: center;
            color: #f8a848;
            margin-bottom: 15px;
            font-size: 24px;
        }

        #journal-search-container {
            margin-bottom: 15px;
            position: relative;
        }

        #journal-search {
            width: 100%;
            padding: 10px 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: rgba(40, 40, 70, 0.9);
            border: 2px solid #5b8cbe;
            border-radius: 4px;
            color: #fcfcfc;
            outline: none;
        }

        #journal-search:focus {
            border-color: #7ec850;
        }

        #journal-search::placeholder {
            color: #888;
        }

        #search-results-count {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: #888;
        }

        .journal-world-section {
            margin-bottom: 20px;
        }

        .journal-world-header {
            font-size: 16px;
            padding: 8px 12px;
            margin-bottom: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .journal-world-header .world-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .journal-world-header .world-icon {
            width: 24px;
            height: 24px;
            image-rendering: pixelated;
        }

        .journal-world-header .world-progress {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .journal-entry.hidden-by-search {
            display: none;
        }

        .highlight {
            background: #f8a848;
            color: #202020;
            padding: 0 2px;
            border-radius: 2px;
        }

        .journal-entry {
            background: rgba(40, 40, 70, 0.8);
            border: 2px solid #4a4a6a;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .journal-entry.collected {
            border-color: #7ec850;
        }

        .journal-entry .speaker-name {
            color: #f8a848;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .journal-entry .speaker-org {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .journal-entry .speaker-link {
            color: #8fd3ff;
            font-size: 12px;
            text-decoration: underline;
        }

        .journal-entry .speaker-link:hover {
            color: #f8a848;
        }

        .journal-entry .insight-text {
            color: #7ec850;
            font-style: italic;
            font-size: 13px;
            line-height: 1.4;
        }

        .journal-entry .not-collected {
            color: #666;
            font-style: italic;
        }

        .checkmark {
            color: #7ec850;
        }

        #journal-close {
            text-align: center;
            margin-top: 20px;
            color: #aaa;
            font-size: 12px;
        }

        /* Victory Screen */
        #victory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #1a3a1a 0%, #2d4a2d 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fcfcfc;
            text-align: center;
            z-index: 100;
            padding: 20px;
        }

        #victory-screen h1 {
            font-size: 28px;
            color: #f8a848;
            text-shadow: 3px 3px 0 #202020;
            margin-bottom: 20px;
        }

        #victory-screen p {
            font-size: 16px;
            color: #7ec850;
            margin-bottom: 10px;
            max-width: 400px;
            line-height: 1.6;
        }

        #victory-screen .prompt {
            margin-top: 30px;
            animation: blink 1s infinite;
        }

        /* Zoom/Map overlay */
        #zoom-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 20, 40, 0.95);
            z-index: 70;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        #zoom-overlay h2 {
            color: #f8a848;
            margin-bottom: 20px;
            font-size: 20px;
        }

        #zoom-canvas {
            border: 3px solid #4a4a6a;
            image-rendering: pixelated;
            cursor: pointer;
        }

        #zoom-instructions {
            margin-top: 15px;
            color: #aaa;
            font-size: 12px;
        }

        .world-label {
            position: absolute;
            color: #fcfcfc;
            font-size: 10px;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }

        /* Navigation Links */
        #nav-links {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 240px; /* Gap to space them around the inventory (which is ~150px wide) */
            z-index: 45; /* Above HUD but below Journal/Dialogues */
            pointer-events: none; /* Container ignores clicks */
            width: 100%;
            justify-content: center;
        }

        .nav-icon {
            width: 36px;
            height: 36px;
            background: rgba(20, 20, 40, 0.9);
            border: 2px solid #4a4a6a;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            cursor: pointer;
            pointer-events: auto; /* Buttons accept clicks */
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        .nav-icon:hover {
            border-color: #f8a848;
            transform: translateY(-2px);
            background: rgba(40, 40, 60, 1);
        }

        .nav-icon img {
            width: 22px;
            height: 22px;
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="640" height="480"></canvas>

        <div id="ui-overlay">
            <!-- Navigation Links -->
            <div id="nav-links">
                <a href="../index.html" class="nav-icon" title="Back to Guide">
                    <img src="../nav-icon-guide.svg" alt="Guide">
                </a>
                <a href="../cards.html" class="nav-icon" title="Go to Cards">
                    <img src="../nav-icon-cards.svg" alt="Cards">
                </a>
            </div>

            <!-- Title Screen -->
            <div id="title-screen">
                <h1>VIBE CODE CAMP</h1>
                <h2>An Every Livestream RPG</h2>
                <p class="prompt">Press SPACE to start</p>
                <div class="controls">
                    Arrow Keys: Move | SPACE: Talk<br>
                    J: Journal | M: Sound | Z: World Map
                </div>
            </div>

            <!-- HUD -->
            <div id="hud" class="hidden">
                <div class="hud-left">
                    <div id="world-name">Hub</div>
                    <div id="insight-counter">Insights: 0/20</div>
                </div>
                <div class="hud-right">
                    <div id="zoom-hint">[Z] Map</div>
                    <div id="sound-toggle">[M] Sound: ON</div>
                    <div id="journal-hint">[J] Journal</div>
                </div>
            </div>

            <!-- World Inventory -->
            <div id="world-inventory" class="hidden"></div>

            <!-- Dialogue Box -->
            <div id="dialogue-box" class="hidden">
                <div id="dialogue-speaker"></div>
                <a id="dialogue-link" href="#" target="_blank" rel="noopener noreferrer"></a>
                <div id="dialogue-text"></div>
                <div id="dialogue-prompt">SPACE to continue</div>
            </div>

            <!-- Journal Screen -->
            <div id="journal-screen" class="hidden">
                <h2>INSIGHT JOURNAL</h2>
                <div id="journal-search-container">
                    <input type="text" id="journal-search" placeholder="Search speakers, orgs, or insights..." autocomplete="off">
                    <span id="search-results-count"></span>
                </div>
                <div id="journal-entries"></div>
                <div id="journal-close">Press J or ESC to close</div>
            </div>

            <!-- Zoom/World Map Overlay -->
            <div id="zoom-overlay" class="hidden">
                <h2>WORLD MAP</h2>
                <canvas id="zoom-canvas" width="600" height="400"></canvas>
                <div id="zoom-instructions">Click a world to travel | Press Z or ESC to close</div>
            </div>

            <!-- Victory Screen -->
            <div id="victory-screen" class="hidden">
                <h1>CONGRATULATIONS!</h1>
                <p>You've absorbed all the wisdom of Vibe Code Camp!</p>
                <p>From vibe coding to AI agents, from research labs to consulting keeps - you've collected insights from 20 brilliant minds across 5 worlds.</p>
                <p>Now go build something amazing!</p>
                <p class="prompt">Press SPACE to play again</p>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // GAME CONSTANTS
        // ============================================
        const TILE_SIZE = 32;
        const MAP_WIDTH = 20;
        const MAP_HEIGHT = 15;
        const CANVAS_WIDTH = 640;
        const CANVAS_HEIGHT = 480;
        const TOTAL_INSIGHTS = 20;

        // Direction constants
        const DIR = { DOWN: 0, UP: 1, LEFT: 2, RIGHT: 3 };

        // Tile types (shared + world-specific)
        const TILES = {
            GRASS: 0, PATH: 1, WATER: 2, TREE: 3,
            PORTAL: 4, // Magical portal to other worlds
            // World-specific tiles start at 10
            TENT_RED: 10, TENT_BLUE: 11, TENT_GREEN: 12, TENT_PURPLE: 13,
            CAMPFIRE: 14, STAGE: 15,
            // Agent Forge tiles
            FURNACE: 20, GEAR: 21, PIPE: 22, CONVEYOR: 23,
            // Research Spire tiles
            TERMINAL: 30, CRYSTAL: 31, BOOKSHELF: 32, HOLOGRAM: 33,
            // Builder's Guild tiles
            WORKBENCH: 40, ANVIL: 41, TOOLRACK: 42, CRATE: 43,
            // Consulting Keep tiles
            CASTLE_WALL: 50, TOWER: 51, BANNER: 52, THRONE: 53,
            // Vibe Village tiles
            EASEL: 60, HAMMOCK: 61, FLOWER: 62, LANTERN: 63,
            // Hub-specific
            HUB_STATUE: 70, HUB_FOUNTAIN: 71, SIGNPOST: 72
        };

        // ============================================
        // WORLD DEFINITIONS
        // ============================================
        const WORLDS = {
            hub: {
                name: "Central Hub",
                bgColor: '#2d4a2d',
                pathColor: '#c9a86c',
                accentColor: '#a080d0',
                description: "The crossroads of Vibe Code Camp",
                icon: 'compass'
            },
            vibe: {
                name: "Vibe Village",
                bgColor: '#4a3a5a',
                pathColor: '#e8c090',
                accentColor: '#ff9070',
                description: "Where creativity flows into code",
                icon: 'palette'
            },
            agent: {
                name: "Agent Forge",
                bgColor: '#2a2a3a',
                pathColor: '#6a6a7a',
                accentColor: '#ff6040',
                description: "Where machines work while you dream",
                icon: 'robot'
            },
            research: {
                name: "Research Spire",
                bgColor: '#1a2a4a',
                pathColor: '#8090b0',
                accentColor: '#40c0ff',
                description: "Where tomorrow's tools are forged",
                icon: 'flask'
            },
            builder: {
                name: "Builder's Guild",
                bgColor: '#3a2a1a',
                pathColor: '#a08060',
                accentColor: '#d0a040',
                description: "Where one builder moves mountains",
                icon: 'hammer'
            },
            consulting: {
                name: "Consulting Keep",
                bgColor: '#2a2a2a',
                pathColor: '#707070',
                accentColor: '#8080c0',
                description: "Where strategy becomes advantage",
                icon: 'scroll'
            }
        };

        const VIDEO_URL = 'https://www.youtube.com/watch?v=5YBjll9XJlw';
        const SPEAKER_VIDEO_TIMESTAMPS = {
            dan: { t: 0, label: '0:00:00' },
            ben: { t: 1883, label: '0:31:23' },
            ashe: { t: 3596, label: '0:59:56' },
            ryan: { t: 5404, label: '1:30:04' },
            natalia: { t: 7201, label: '2:00:01' },
            nityesh: { t: 7201, label: '2:00:01' },
            katie: { t: 8030, label: '2:13:50' },
            nat: { t: 9023, label: '2:30:23' },
            tina: { t: 10969, label: '3:02:49' },
            paula: { t: 12660, label: '3:31:00' },
            cj: { t: 14530, label: '4:02:10' },
            logan: { t: 16301, label: '4:31:41' },
            ammaar: { t: 16301, label: '4:31:41' },
            geoffrey: { t: 17995, label: '4:59:55' },
            kevin: { t: 19791, label: '5:29:51' },
            kieran: { t: 19791, label: '5:29:51' },
            thariq: { t: 21740, label: '6:02:20' },
            naveen: { t: 23447, label: '6:30:47' },
            yash: { t: 25178, label: '6:59:38' },
            brooker: { t: 26976, label: '7:29:36' }
        };

        // ============================================
        // SPEAKER DATA (organized by world)
        // ============================================
        const SPEAKERS = {
            vibe: [
                {
                    id: 'dan', name: 'Dan Shipper', org: 'CEO, Every',
                    x: 5, y: 4, color: '#ff9070',
                    greeting: "I built Proof, an agent-native markdown editor, entirely through vibe coding in my spare time.",
                    insight: "I vibe coded Proof in my spare time. It should've taken 6 months. I have no idea how the code works... and that's okay!",
                    followUp: "Ideas, Apps, Training - that's what we do at Every. Keep exploring!"
                },
                {
                    id: 'tina', name: 'Tina He', org: 'Pace Capital',
                    x: 14, y: 4, color: '#e048a8',
                    greeting: "I treat vibe coding like meditation - from non-coder to shipping daily.",
                    insight: "Vibe coding is a creative practice. I started with RPG Maker as a kid, now I ship apps daily with AI.",
                    followUp: "The best creations come from human vision + AI capability."
                },
                {
                    id: 'paula', name: 'Paula Dozsa', org: 'iOS Engineer, Portola',
                    x: 5, y: 10, color: '#48a8a8',
                    greeting: "I built a 200K MAU iOS app with zero iOS experience using AI tools.",
                    insight: "You don't need years of experience anymore. AI lets you learn by building real products.",
                    followUp: "Design for outcomes, not for showing off AI capabilities."
                },
                {
                    id: 'katie', name: 'Katie Parrott', org: 'Staff Writer, Every',
                    x: 14, y: 10, color: '#80a048',
                    greeting: "I'm the AI editorial lead at Every. I use Claude Code for writing, not just coding.",
                    insight: "Claude is your writing partner, not replacement. I coded 6 apps in a 2-week vibe coding haze!",
                    followUp: "Talk to users. The AI won't tell you what to build."
                }
            ],
            agent: [
                {
                    id: 'nat', name: 'Nat Eliason', org: 'Author & Builder',
                    x: 5, y: 4, color: '#ff6040',
                    greeting: "I run ClaudeBot 24/7 on a Mac Mini - an AI agent that works while I sleep.",
                    insight: "I have Claude running unsupervised around the clock. It handles tasks autonomously while I focus on what matters.",
                    followUp: "The future is agents that work for you 24/7. Start building yours."
                },
                {
                    id: 'ben', name: 'Ben Tossell', org: "Ben's Bites / Factory",
                    x: 14, y: 4, color: '#f86848',
                    greeting: "I can't code. Still can't. Never will. But I run 30 AI agents autonomously.",
                    insight: "Find other agents' code, adapt it for your needs. I run 30 agents autonomously doing real work!",
                    followUp: "I built MakerPad and sold it to Zapier. All without coding a single line."
                },
                {
                    id: 'ryan', name: 'Ryan Carson', org: 'Founder, Untangle',
                    x: 5, y: 10, color: '#34a853',
                    greeting: "I built an infinite loop agent that never stops working - it improves products autonomously.",
                    insight: "We need to be looping to autonomously improve our products. Compound product is the future.",
                    followUp: "The best education is project-based. AI makes that accessible to everyone."
                },
                {
                    id: 'ashe', name: 'Ashe Magalhaes', org: 'Hearth AI',
                    x: 14, y: 10, color: '#a848a8',
                    greeting: "I'm building a personal AI suite that knows your whole life - photos, notes, everything.",
                    insight: "The weirdest experiments often lead to the most useful products. I'm training AI on my entire life's data.",
                    followUp: "Don't be afraid to build something that seems silly at first."
                }
            ],
            research: [
                {
                    id: 'geoffrey', name: 'Geoffrey Litt', org: 'Design Engineer, Notion',
                    x: 5, y: 4, color: '#40c0ff',
                    greeting: "I research malleable software at Notion - apps that can rewrite themselves with AI.",
                    insight: "We're entering an era of personal software - tools built exactly for your needs, by you!",
                    followUp: "Imagine a world where everyone can create their own perfect tools."
                },
                {
                    id: 'thariq', name: 'Thariq Shihipar', org: 'Anthropic',
                    x: 14, y: 4, color: '#8080ff',
                    greeting: "I work at Anthropic on Claude Code. Happy to share what we're building!",
                    insight: "Tasks will replace to-dos. AI agents that actually complete work, not just remind you about it.",
                    followUp: "We're building Claude to be a true collaborator. Keep experimenting!"
                },
                {
                    id: 'logan', name: 'Logan Kilpatrick', org: 'Google AI Studio',
                    x: 5, y: 10, color: '#4285f4',
                    greeting: "I work on AI Studio at Google - making AI accessible to every developer.",
                    insight: "The best time to start building with AI was yesterday. The second best time is now!",
                    followUp: "Don't wait for the perfect model. Start with what's available today."
                },
                {
                    id: 'ammaar', name: 'Ammaar Reshi', org: 'Google AI Studio',
                    x: 14, y: 10, color: '#ea4335',
                    greeting: "I lead product and design on AI Studio. I also made an AI-generated children's book!",
                    insight: "Document your AI journey. I've been hacking on AI since ChatGPT launched - code, video, everything.",
                    followUp: "Share what you learn. The community grows when we share."
                }
            ],
            builder: [
                {
                    id: 'cj', name: 'CJ Hess', org: 'Engineer, Tenex',
                    x: 5, y: 4, color: '#d0a040',
                    greeting: "I built Context7, an MCP that teaches Claude every framework automatically.",
                    insight: "The MCP pulls in live documentation so Claude always has the latest context. No more outdated answers!",
                    followUp: "Context is everything. Give Claude the right docs and it becomes unstoppable."
                },
                {
                    id: 'naveen', name: 'Naveen Naidu', org: 'GM of Monologue, Every',
                    x: 14, y: 4, color: '#48a848',
                    greeting: "I built Monologue - a voice-to-text app competing with VC-backed giants. Just me and AI.",
                    insight: "One developer can now compete with entire teams. AI hasn't replaced programmers - it's made us 10x more ambitious!",
                    followUp: "Projects that seemed impossible are now weekend builds."
                },
                {
                    id: 'yash', name: 'Yash Poojary', org: 'GM of Sparkle, Every',
                    x: 5, y: 10, color: '#a8a848',
                    greeting: "I built Sparkle, an AI file organizer. I also reverse engineer ChatGPT and Spotify to learn faster.",
                    insight: "Speed is a feature. I reverse engineer apps to understand their AI - then build my own version faster.",
                    followUp: "Don't wait for perfect. Launch and improve."
                },
                {
                    id: 'kevin', name: 'Kevin Rose', org: 'True Ventures',
                    x: 14, y: 10, color: '#a0a0a0',
                    greeting: "I invest in AI-native companies and practice compound engineering.",
                    insight: "Plan, work, review, compound. That's the loop that makes AI coding actually work.",
                    followUp: "Good design principles apply whether you write code or vibe it."
                }
            ],
            consulting: [
                {
                    id: 'kieran', name: 'Kieran Klaassen', org: 'GM of Quora, Every',
                    x: 5, y: 4, color: '#8080c0',
                    greeting: "I originated compound engineering - the workflow that changed how we build with AI.",
                    insight: "The magic happens when you treat AI as a true collaborator, not just a tool. Plan, execute, review, repeat.",
                    followUp: "It's like having a junior dev who never gets tired."
                },
                {
                    id: 'natalia', name: 'Natalia Quintero', org: 'Every Consulting',
                    x: 14, y: 4, color: '#e0a048',
                    greeting: "I turn 20-hour consulting decks into 2-hour workflows with AI.",
                    insight: "Most companies don't need custom AI. They need better prompts and workflows for existing tools!",
                    followUp: "Start simple. You'd be surprised how far basic prompting gets you."
                },
                {
                    id: 'nityesh', name: 'Nityesh Agarwal', org: 'Every Consulting',
                    x: 5, y: 10, color: '#48e0a8',
                    greeting: "I help build AI consulting workflows that save hours of repetitive work.",
                    insight: "The best way to learn AI is to build with it. Theory only gets you so far - start building!",
                    followUp: "Pick a project and start. That's the only way to really understand."
                },
                {
                    id: 'brooker', name: 'Brooker Belcourt', org: 'Every Consulting',
                    x: 14, y: 10, color: '#a04880',
                    greeting: "I spent a decade at hedge funds. Now I do 5-hour research in 20 minutes with Claude.",
                    insight: "Claude is an incredibly powerful research assistant. I use it in the terminal for financial analysis daily.",
                    followUp: "AI for research isn't about building apps - it's about thinking faster."
                }
            ]
        };

        // ============================================
        // MAP DATA FOR EACH WORLD
        // ============================================
        const MAPS = {
            hub: [
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                [3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 3],
                [3, 0, 72, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 72, 0, 0, 3],
                [3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 3],
                [3, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 3],
                [3, 0, 0, 1, 0, 0, 0, 0, 0, 70, 71, 0, 0, 0, 0, 0, 1, 0, 0, 3],
                [3, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3],
                [4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4],
                [4, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 4],
                [3, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3],
                [3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 3],
                [3, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 3],
                [3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 3],
                [3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 3],
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3],
            ],
            vibe: [
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                [3, 62, 0, 63, 0, 62, 0, 61, 0, 0, 0, 0, 61, 0, 62, 0, 63, 0, 62, 3],
                [3, 0, 63, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 0, 63, 0, 3],
                [3, 63, 0, 60, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 60, 0, 63, 3],
                [3, 0, 0, 1, 1, 1, 62, 62, 0, 14, 14, 0, 62, 62, 1, 1, 1, 0, 0, 3],
                [3, 0, 0, 1, 0, 63, 0, 61, 0, 0, 0, 0, 61, 0, 63, 0, 1, 0, 0, 3],
                [3, 0, 0, 1, 0, 0, 62, 0, 0, 0, 0, 0, 0, 62, 0, 0, 1, 0, 0, 3],
                [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 4, 4],
                [1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 4],
                [3, 0, 0, 1, 0, 60, 0, 63, 0, 0, 0, 0, 63, 0, 60, 0, 1, 0, 0, 3],
                [3, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 3],
                [3, 0, 63, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 60, 0, 63, 0, 3],
                [3, 62, 63, 0, 0, 62, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 0, 63, 62, 3],
                [3, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 63, 0, 3],
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
            ],
            agent: [
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                [3, 22, 22, 22, 0, 21, 0, 20, 20, 0, 0, 20, 20, 0, 21, 0, 22, 22, 22, 3],
                [3, 22, 0, 21, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 21, 0, 22, 3],
                [3, 22, 0, 21, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 21, 0, 22, 3],
                [3, 0, 0, 1, 1, 1, 0, 21, 0, 23, 23, 0, 21, 0, 1, 1, 1, 0, 0, 3],
                [3, 0, 0, 1, 0, 22, 0, 21, 0, 23, 23, 0, 21, 0, 22, 0, 1, 0, 0, 3],
                [3, 20, 0, 1, 0, 0, 21, 0, 0, 23, 23, 0, 0, 21, 0, 0, 1, 0, 20, 3],
                [4, 4, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 20, 3],
                [4, 4, 0, 1, 0, 22, 0, 0, 0, 0, 0, 0, 0, 22, 0, 0, 1, 0, 0, 3],
                [3, 0, 0, 1, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 1, 0, 0, 3],
                [3, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 3],
                [3, 22, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 0, 0, 22, 3],
                [3, 22, 22, 22, 0, 21, 0, 20, 20, 0, 0, 20, 20, 0, 21, 0, 22, 22, 22, 3],
                [3, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 3],
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
            ],
            research: [
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                [3, 31, 0, 0, 33, 0, 0, 30, 30, 1, 1, 30, 30, 0, 33, 0, 0, 0, 31, 3],
                [3, 0, 32, 0, 32, 0, 0, 0, 0, 1, 1, 0, 0, 0, 32, 0, 0, 32, 0, 3],
                [3, 0, 30, 33, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 33, 30, 0, 3],
                [3, 0, 0, 1, 1, 1, 31, 0, 0, 31, 31, 0, 0, 31, 1, 1, 1, 0, 0, 3],
                [3, 0, 0, 1, 0, 33, 0, 30, 0, 0, 0, 0, 30, 0, 33, 0, 1, 0, 0, 3],
                [3, 32, 0, 1, 0, 0, 31, 0, 0, 0, 0, 0, 0, 31, 0, 0, 1, 0, 32, 3],
                [3, 32, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 32, 3],
                [3, 0, 0, 1, 0, 30, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 1, 0, 0, 3],
                [3, 0, 0, 1, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 1, 0, 0, 3],
                [3, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 3],
                [3, 0, 32, 0, 31, 0, 0, 0, 0, 1, 1, 0, 0, 0, 31, 0, 0, 32, 0, 3],
                [3, 31, 0, 0, 33, 0, 0, 30, 30, 1, 1, 30, 30, 0, 33, 0, 0, 0, 31, 3],
                [3, 0, 31, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 31, 0, 3],
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3],
            ],
            builder: [
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                [3, 43, 0, 42, 0, 0, 0, 40, 40, 1, 1, 40, 40, 0, 0, 42, 0, 0, 43, 3],
                [3, 0, 42, 0, 43, 0, 0, 0, 0, 1, 1, 0, 0, 0, 43, 0, 0, 42, 0, 3],
                [3, 0, 42, 41, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 41, 42, 0, 3],
                [3, 0, 0, 1, 1, 1, 40, 0, 0, 43, 43, 0, 0, 40, 1, 1, 1, 0, 0, 3],
                [3, 0, 0, 1, 0, 41, 0, 40, 0, 0, 0, 0, 40, 0, 41, 0, 1, 0, 0, 3],
                [3, 42, 0, 1, 0, 0, 43, 0, 0, 0, 0, 0, 0, 43, 0, 0, 1, 0, 42, 3],
                [3, 42, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 42, 3],
                [3, 0, 0, 1, 0, 42, 0, 0, 0, 0, 0, 0, 0, 42, 0, 0, 1, 0, 0, 3],
                [3, 0, 0, 1, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 1, 0, 0, 3],
                [3, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 3],
                [3, 0, 42, 0, 43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 0, 0, 42, 0, 3],
                [3, 43, 0, 0, 42, 0, 0, 40, 40, 0, 0, 40, 40, 0, 0, 42, 0, 0, 43, 3],
                [3, 0, 43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 0, 3],
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
            ],
            consulting: [
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
                [3, 51, 50, 52, 50, 50, 50, 50, 50, 0, 0, 50, 50, 50, 50, 52, 50, 50, 51, 3],
                [3, 50, 0, 0, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 0, 50, 3],
                [3, 50, 0, 52, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 52, 0, 50, 3],
                [3, 50, 0, 1, 1, 1, 52, 0, 0, 53, 53, 0, 0, 52, 1, 1, 1, 0, 50, 3],
                [3, 50, 0, 1, 0, 0, 0, 52, 0, 0, 0, 0, 52, 0, 0, 0, 1, 0, 50, 3],
                [3, 50, 0, 1, 0, 52, 0, 0, 0, 0, 0, 0, 0, 52, 0, 0, 1, 0, 50, 3],
                [3, 50, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 50, 3],
                [3, 50, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 50, 3],
                [3, 50, 0, 1, 0, 52, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 1, 0, 50, 3],
                [3, 50, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 50, 3],
                [3, 50, 0, 0, 0, 52, 0, 0, 0, 1, 1, 0, 0, 0, 52, 0, 0, 0, 50, 3],
                [3, 51, 50, 52, 50, 50, 50, 50, 50, 1, 1, 50, 50, 50, 50, 52, 50, 50, 51, 3],
                [3, 0, 52, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 52, 0, 3],
                [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
            ]
        };

        // World adjacency for NES-style edge transitions
        const WORLD_NEIGHBORS = {
            hub: { north: 'research', south: 'builder', west: 'vibe', east: 'agent' },
            research: { south: 'hub', north: 'consulting' },
            consulting: { south: 'research' },
            builder: { north: 'hub' },
            vibe: { east: 'hub' },
            agent: { west: 'hub' }
        };

        const EXIT_ZONES = {
            north: [{ x: 9, y: 0 }, { x: 10, y: 0 }],
            south: [{ x: 9, y: 14 }, { x: 10, y: 14 }],
            west: [{ x: 0, y: 7 }, { x: 0, y: 8 }],
            east: [{ x: 19, y: 7 }, { x: 19, y: 8 }]
        };

        const TRANSITION_SPEED = 0.4; // pixels per ms

        // Spawn points when entering each world
        const SPAWN_POINTS = {
            hub: { x: 9, y: 12 },
            vibe: { x: 9, y: 12 },
            agent: { x: 9, y: 12 },
            research: { x: 9, y: 12 },
            builder: { x: 9, y: 12 },
            consulting: { x: 9, y: 12 }
        };

        // ============================================
        // AUDIO SYSTEM
        // ============================================
        let audioCtx = null;
        let masterGain = null;
        let musicGain = null;
        let sfxGain = null;
        let soundEnabled = true;
        let musicPlaying = false;
        let musicTimeout = null;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioCtx.destination);
            musicGain = audioCtx.createGain();
            musicGain.gain.value = 0.15;
            musicGain.connect(masterGain);
            sfxGain = audioCtx.createGain();
            sfxGain.gain.value = 0.5;
            sfxGain.connect(masterGain);
        }

        function playNote(freq, duration, type = 'square', gainNode = sfxGain, volume = 0.3) {
            if (!audioCtx || !soundEnabled) return;
            const osc = audioCtx.createOscillator();
            const noteGain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            noteGain.gain.setValueAtTime(volume, audioCtx.currentTime);
            noteGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
            osc.connect(noteGain);
            noteGain.connect(gainNode);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + duration);
            return osc;
        }

        function playFootstep() {
            if (!soundEnabled) return;
            const pitch = Math.random() > 0.5 ? 100 : 110;
            playNote(pitch, 0.05, 'triangle', sfxGain, 0.15);
        }

        function playTalkStart() {
            if (!soundEnabled) return;
            playNote(330, 0.08, 'square', sfxGain, 0.2);
            setTimeout(() => playNote(392, 0.08, 'square', sfxGain, 0.2), 60);
            setTimeout(() => playNote(523, 0.12, 'square', sfxGain, 0.25), 120);
        }

        function playTextBlip() {
            if (!soundEnabled) return;
            const freq = 440 + Math.random() * 60;
            playNote(freq, 0.03, 'square', sfxGain, 0.08);
        }

        function playDialogueAdvance() {
            if (!soundEnabled) return;
            playNote(600, 0.05, 'square', sfxGain, 0.15);
        }

        function playInsightCollected() {
            if (!soundEnabled) return;
            const notes = [523, 659, 784, 1047];
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    playNote(freq, 0.3, 'triangle', sfxGain, 0.3);
                    playNote(freq * 1.5, 0.3, 'sine', sfxGain, 0.15);
                }, i * 100);
            });
        }

        function playPortalSound() {
            if (!soundEnabled) return;
            // Whooshing magical sound
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    playNote(200 + i * 100, 0.15, 'sine', sfxGain, 0.2 - i * 0.03);
                }, i * 50);
            }
        }

        function playMenuOpen() {
            if (!soundEnabled) return;
            playNote(300, 0.08, 'square', sfxGain, 0.2);
            setTimeout(() => playNote(450, 0.1, 'square', sfxGain, 0.2), 50);
        }

        function playMenuClose() {
            if (!soundEnabled) return;
            playNote(450, 0.08, 'square', sfxGain, 0.2);
            setTimeout(() => playNote(300, 0.1, 'square', sfxGain, 0.2), 50);
        }

        function playVictoryFanfare() {
            if (!soundEnabled) return;
            const melody = [
                { freq: 523, dur: 0.15 }, { freq: 523, dur: 0.15 },
                { freq: 523, dur: 0.15 }, { freq: 523, dur: 0.4 },
                { freq: 415, dur: 0.4 }, { freq: 466, dur: 0.4 },
                { freq: 523, dur: 0.15 }, { freq: 466, dur: 0.1 },
                { freq: 523, dur: 0.6 },
            ];
            let time = 0;
            melody.forEach(note => {
                setTimeout(() => {
                    playNote(note.freq, note.dur, 'square', sfxGain, 0.35);
                    playNote(note.freq * 0.5, note.dur, 'triangle', sfxGain, 0.2);
                }, time);
                time += note.dur * 800;
            });
        }

        // World-specific music themes
        const MUSIC_THEMES = {
            hub: { 
                baseNote: 392, 
                scale: [0, 2, 4, 7, 9], // G Major Pentatonic - Open, welcoming, adventurous
                tempo: 400,
                type: 'triangle',
                bassType: 'sine'
            }, 
            vibe: { 
                baseNote: 349, 
                scale: [0, 4, 7, 11, 14], // F Major 7th arpeggio - Dreamy, ethereal, chill
                tempo: 300,
                type: 'sine',
                bassType: 'triangle'
            }, 
            agent: { 
                baseNote: 330, 
                scale: [0, 3, 7, 10, 12], // E Minor 7th - Mechanical, focused, persistent
                tempo: 250,
                type: 'square',
                bassType: 'sawtooth'
            }, 
            research: { 
                baseNote: 440, 
                scale: [0, 2, 6, 7, 11], // A Lydian - Futuristic, curious, scientific
                tempo: 350,
                type: 'sine',
                bassType: 'square'
            }, 
            builder: { 
                baseNote: 294, 
                scale: [0, 2, 5, 7, 10], // D Mixolydian (ish) - Sturdy, crafting, industrial
                tempo: 450,
                type: 'triangle',
                bassType: 'sawtooth'
            }, 
            consulting: { 
                baseNote: 262, 
                scale: [0, 3, 5, 7, 10], // C Dorian - Strategic, sophisticated, thoughtful
                tempo: 500,
                type: 'triangle',
                bassType: 'sine'
            }  
        };

        let currentMusicIndex = 0;
        let currentBassIndex = 0;

        function startMusic() {
            if (!audioCtx || !soundEnabled || musicPlaying) return;
            musicPlaying = true;
            currentMusicIndex = 0;
            currentBassIndex = 0;
            playMusicNote();
        }

        function stopMusic() {
            musicPlaying = false;
            if (musicTimeout) {
                clearTimeout(musicTimeout);
                musicTimeout = null;
            }
        }

        function playMusicNote() {
            if (!musicPlaying || !soundEnabled) return;

            const theme = MUSIC_THEMES[gameState.currentWorld] || MUSIC_THEMES.hub;
            const scaleIndex = currentMusicIndex % theme.scale.length;
            const octave = Math.floor(currentMusicIndex / theme.scale.length) % 2;
            
            // Randomize octave slightly for variety
            const randomOctaveOffset = Math.random() > 0.8 ? 1 : 0;
            
            const noteFreq = theme.baseNote * Math.pow(2, (theme.scale[scaleIndex] + (octave + randomOctaveOffset) * 12) / 12);

            // Melody
            if (currentMusicIndex % 2 === 0 || Math.random() > 0.3) {
                playNote(noteFreq, theme.tempo / 1000 * 0.8, theme.type, musicGain, 0.2);
            }

            // Bass on beats 0 and 4
            if (currentMusicIndex % 4 === 0) {
                playNote(theme.baseNote / 2, theme.tempo / 1000, theme.bassType, musicGain, 0.15);
            }
            
            // Occasional arpeggio or flourish
            if (currentMusicIndex % 8 === 7 && Math.random() > 0.5) {
                 setTimeout(() => {
                     playNote(noteFreq * 1.5, 0.1, theme.type, musicGain, 0.1);
                 }, theme.tempo / 2);
            }

            currentMusicIndex = (currentMusicIndex + 1) % 16;
            musicTimeout = setTimeout(playMusicNote, theme.tempo);
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const toggle = document.getElementById('sound-toggle');
            if (soundEnabled) {
                toggle.textContent = '[M] Sound: ON';
                toggle.classList.remove('muted');
                if (gameState.screen === 'game') startMusic();
            } else {
                toggle.textContent = '[M] Sound: OFF';
                toggle.classList.add('muted');
                stopMusic();
            }
        }

        // ============================================
        // GAME STATE
        // ============================================
        let gameState = {
            screen: 'title',
            currentWorld: 'hub',
            player: { x: 9, y: 12, dir: DIR.DOWN, moving: false, animFrame: 0 },
            transition: { active: false, direction: null, from: null, to: null, progress: 0, targetX: 0, targetY: 0 },
            collectedInsights: new Set(),
            dialogue: {
                active: false, speaker: null, lines: [], currentLine: 0,
                charIndex: 0, fullText: '', displayText: '', isTyping: false
            },
            lastTime: 0, moveTimer: 0, typeTimer: 0, animTimer: 0
        };

        const keys = {
            up: false, down: false, left: false, right: false,
            space: false, j: false, esc: false, m: false, z: false
        };

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        const zoomCanvas = document.getElementById('zoom-canvas');
        const zoomCtx = zoomCanvas.getContext('2d');
        zoomCtx.imageSmoothingEnabled = false;

        // UI Elements
        const titleScreen = document.getElementById('title-screen');
        const hud = document.getElementById('hud');
        const dialogueBox = document.getElementById('dialogue-box');
        const dialogueSpeaker = document.getElementById('dialogue-speaker');
        const dialogueLink = document.getElementById('dialogue-link');
        const dialogueText = document.getElementById('dialogue-text');
        const journalScreen = document.getElementById('journal-screen');
        const journalEntries = document.getElementById('journal-entries');
        const insightCounter = document.getElementById('insight-counter');
        const victoryScreen = document.getElementById('victory-screen');
        const zoomOverlay = document.getElementById('zoom-overlay');
        const worldNameDisplay = document.getElementById('world-name');
        const worldInventory = document.getElementById('world-inventory');

        // ============================================
        // WORLD INVENTORY DISPLAY
        // ============================================
        function initWorldInventory() {
            const inventoryWorlds = ['vibe', 'agent', 'research', 'builder', 'consulting'];
            worldInventory.innerHTML = '';

            for (const worldId of inventoryWorlds) {
                const world = WORLDS[worldId];
                const speakers = SPEAKERS[worldId] || [];

                const worldEl = document.createElement('div');
                worldEl.className = 'inventory-world';
                worldEl.dataset.worldId = worldId;
                worldEl.title = `${world.name}: ${world.description}`;

                const iconCanvas = document.createElement('canvas');
                iconCanvas.width = 24;
                iconCanvas.height = 24;
                const iconCtx = iconCanvas.getContext('2d');
                drawWorldIcon(iconCtx, world.icon, 0, 0, 24, world.accentColor);

                const countEl = document.createElement('div');
                countEl.className = 'count';
                countEl.textContent = `0/${speakers.length}`;

                worldEl.appendChild(iconCanvas);
                worldEl.appendChild(countEl);
                worldInventory.appendChild(worldEl);
            }
        }

        function updateWorldInventory() {
            const inventoryWorlds = document.querySelectorAll('.inventory-world');

            for (const worldEl of inventoryWorlds) {
                const worldId = worldEl.dataset.worldId;
                const speakers = SPEAKERS[worldId] || [];
                const collected = speakers.filter(s => gameState.collectedInsights.has(s.id)).length;
                const total = speakers.length;

                const countEl = worldEl.querySelector('.count');
                countEl.textContent = `${collected}/${total}`;

                worldEl.classList.remove('has-insights', 'complete', 'current');

                if (collected > 0) {
                    worldEl.classList.add('has-insights');
                }
                if (collected === total) {
                    worldEl.classList.add('complete');
                }
                if (worldId === gameState.currentWorld) {
                    worldEl.classList.add('current');
                }
            }
        }

        // ============================================
        // RENDERING FUNCTIONS
        // ============================================
        function getWorldColors(worldId) {
            const world = WORLDS[worldId];
            return {
                grass: world.bgColor,
                grassDark: shadeColor(world.bgColor, -20),
                path: world.pathColor,
                pathDark: shadeColor(world.pathColor, -15),
                accent: world.accentColor
            };
        }

        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, Math.min(255, (num >> 16) + amt));
            const G = Math.max(0, Math.min(255, (num >> 8 & 0x00FF) + amt));
            const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // ============================================
        // WORLD ICON DRAWING (16x16 pixel icons)
        // ============================================
        function drawWorldIcon(targetCtx, iconType, x, y, size = 16, color = '#ffffff') {
            const scale = size / 16;
            targetCtx.save();
            targetCtx.translate(x, y);
            targetCtx.scale(scale, scale);

            switch (iconType) {
                case 'compass': // Central Hub - crossroads/navigation
                    targetCtx.fillStyle = color;
                    // Outer circle
                    targetCtx.beginPath();
                    targetCtx.arc(8, 8, 7, 0, Math.PI * 2);
                    targetCtx.fill();
                    targetCtx.fillStyle = '#1a1a2e';
                    targetCtx.beginPath();
                    targetCtx.arc(8, 8, 5, 0, Math.PI * 2);
                    targetCtx.fill();
                    // Needle
                    targetCtx.fillStyle = '#ff6040';
                    targetCtx.beginPath();
                    targetCtx.moveTo(8, 2);
                    targetCtx.lineTo(10, 8);
                    targetCtx.lineTo(8, 6);
                    targetCtx.lineTo(6, 8);
                    targetCtx.closePath();
                    targetCtx.fill();
                    targetCtx.fillStyle = '#ffffff';
                    targetCtx.beginPath();
                    targetCtx.moveTo(8, 14);
                    targetCtx.lineTo(10, 8);
                    targetCtx.lineTo(8, 10);
                    targetCtx.lineTo(6, 8);
                    targetCtx.closePath();
                    targetCtx.fill();
                    break;

                case 'palette': // Vibe Village - creativity
                    targetCtx.fillStyle = color;
                    // Palette shape
                    targetCtx.beginPath();
                    targetCtx.ellipse(8, 9, 7, 6, 0, 0, Math.PI * 2);
                    targetCtx.fill();
                    // Thumb hole
                    targetCtx.fillStyle = '#1a1a2e';
                    targetCtx.beginPath();
                    targetCtx.arc(4, 10, 2, 0, Math.PI * 2);
                    targetCtx.fill();
                    // Color dots
                    targetCtx.fillStyle = '#ff6040';
                    targetCtx.beginPath();
                    targetCtx.arc(7, 5, 1.5, 0, Math.PI * 2);
                    targetCtx.fill();
                    targetCtx.fillStyle = '#40c0ff';
                    targetCtx.beginPath();
                    targetCtx.arc(11, 6, 1.5, 0, Math.PI * 2);
                    targetCtx.fill();
                    targetCtx.fillStyle = '#7ec850';
                    targetCtx.beginPath();
                    targetCtx.arc(12, 10, 1.5, 0, Math.PI * 2);
                    targetCtx.fill();
                    targetCtx.fillStyle = '#f8a848';
                    targetCtx.beginPath();
                    targetCtx.arc(9, 12, 1.5, 0, Math.PI * 2);
                    targetCtx.fill();
                    break;

                case 'robot': // Agent Forge - automation
                    targetCtx.fillStyle = color;
                    // Head
                    targetCtx.fillRect(3, 3, 10, 8);
                    // Antenna
                    targetCtx.fillRect(7, 0, 2, 3);
                    targetCtx.fillStyle = '#ff6040';
                    targetCtx.beginPath();
                    targetCtx.arc(8, 0, 2, 0, Math.PI * 2);
                    targetCtx.fill();
                    // Eyes
                    targetCtx.fillStyle = '#40c0ff';
                    targetCtx.fillRect(5, 5, 2, 2);
                    targetCtx.fillRect(9, 5, 2, 2);
                    // Mouth
                    targetCtx.fillStyle = '#1a1a2e';
                    targetCtx.fillRect(5, 8, 6, 2);
                    // Body
                    targetCtx.fillStyle = color;
                    targetCtx.fillRect(4, 11, 8, 5);
                    targetCtx.fillStyle = '#7ec850';
                    targetCtx.fillRect(6, 12, 1, 1);
                    targetCtx.fillRect(9, 12, 1, 1);
                    break;

                case 'flask': // Research Spire - science
                    targetCtx.fillStyle = color;
                    // Neck
                    targetCtx.fillRect(6, 1, 4, 5);
                    // Rim
                    targetCtx.fillRect(5, 1, 6, 2);
                    // Body (conical)
                    targetCtx.beginPath();
                    targetCtx.moveTo(6, 6);
                    targetCtx.lineTo(2, 14);
                    targetCtx.lineTo(14, 14);
                    targetCtx.lineTo(10, 6);
                    targetCtx.closePath();
                    targetCtx.fill();
                    // Liquid
                    targetCtx.fillStyle = '#40c0ff';
                    targetCtx.beginPath();
                    targetCtx.moveTo(4, 10);
                    targetCtx.lineTo(3, 13);
                    targetCtx.lineTo(13, 13);
                    targetCtx.lineTo(12, 10);
                    targetCtx.closePath();
                    targetCtx.fill();
                    // Bubbles
                    targetCtx.fillStyle = '#80e0ff';
                    targetCtx.beginPath();
                    targetCtx.arc(6, 11, 1, 0, Math.PI * 2);
                    targetCtx.fill();
                    targetCtx.beginPath();
                    targetCtx.arc(10, 12, 0.8, 0, Math.PI * 2);
                    targetCtx.fill();
                    break;

                case 'hammer': // Builder's Guild - crafting
                    targetCtx.fillStyle = '#8b5a2b';
                    // Handle
                    targetCtx.save();
                    targetCtx.translate(8, 8);
                    targetCtx.rotate(Math.PI / 4);
                    targetCtx.fillRect(-1, -2, 3, 12);
                    targetCtx.restore();
                    // Head
                    targetCtx.fillStyle = color;
                    targetCtx.save();
                    targetCtx.translate(8, 8);
                    targetCtx.rotate(Math.PI / 4);
                    targetCtx.fillRect(-5, -6, 10, 5);
                    targetCtx.fillStyle = shadeColor(color, -20);
                    targetCtx.fillRect(-5, -6, 10, 2);
                    targetCtx.restore();
                    break;

                case 'scroll': // Consulting Keep - strategy
                    targetCtx.fillStyle = color;
                    // Main scroll body
                    targetCtx.fillRect(4, 3, 8, 10);
                    // Top roll
                    targetCtx.beginPath();
                    targetCtx.arc(8, 3, 3, Math.PI, 0);
                    targetCtx.fill();
                    // Bottom roll
                    targetCtx.beginPath();
                    targetCtx.arc(8, 13, 3, 0, Math.PI);
                    targetCtx.fill();
                    // Text lines
                    targetCtx.fillStyle = '#1a1a2e';
                    targetCtx.fillRect(5, 5, 6, 1);
                    targetCtx.fillRect(5, 7, 5, 1);
                    targetCtx.fillRect(5, 9, 6, 1);
                    targetCtx.fillRect(5, 11, 4, 1);
                    break;
            }

            targetCtx.restore();
        }

        // Generate icon as data URL for CSS use
        function getWorldIconDataURL(worldId, size = 24) {
            const world = WORLDS[worldId];
            if (!world) return '';

            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const iconCtx = canvas.getContext('2d');

            drawWorldIcon(iconCtx, world.icon, 0, 0, size, world.accentColor);
            return canvas.toDataURL();
        }

        function drawTile(x, y, type, worldId = gameState.currentWorld) {
            const px = x * TILE_SIZE;
            const py = y * TILE_SIZE;
            const colors = getWorldColors(worldId);

            // Base grass for most tiles
            ctx.fillStyle = colors.grass;
            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);

            switch (type) {
                case TILES.GRASS:
                    // Grass texture
                    ctx.fillStyle = colors.grassDark;
                    for (let i = 0; i < 3; i++) {
                        const gx = px + 5 + (i * 10) + ((x + y) % 3) * 3;
                        const gy = py + 8 + ((i * 7 + x + y) % 10);
                        ctx.fillRect(gx, gy, 2, 4);
                    }
                    break;

                case TILES.PATH:
                    ctx.fillStyle = colors.path;
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    ctx.fillStyle = colors.pathDark;
                    ctx.fillRect(px + 4, py + 4, 3, 3);
                    ctx.fillRect(px + 20, py + 12, 3, 3);
                    ctx.fillRect(px + 10, py + 24, 3, 3);
                    break;

                case TILES.TREE:
                    ctx.fillStyle = '#6b4a1b';
                    ctx.fillRect(px + 12, py + 20, 8, 12);
                    ctx.fillStyle = '#2d5a1d';
                    ctx.beginPath();
                    ctx.arc(px + 16, py + 12, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#3d7a2d';
                    ctx.beginPath();
                    ctx.arc(px + 12, py + 14, 6, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case TILES.PORTAL:
                    // Magical swirling portal
                    const time = Date.now() / 500;
                    ctx.fillStyle = colors.accent;
                    ctx.beginPath();
                    ctx.arc(px + 16, py + 16, 12 + Math.sin(time) * 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = shadeColor(colors.accent, 30);
                    ctx.beginPath();
                    ctx.arc(px + 16, py + 16, 8 + Math.cos(time) * 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(px + 16, py + 16, 4, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case TILES.CAMPFIRE:
                case 14:
                    ctx.fillStyle = 'rgba(248, 168, 72, 0.3)';
                    ctx.beginPath();
                    ctx.arc(px + 16, py + 16, 14, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#8b5a2b';
                    ctx.fillRect(px + 6, py + 20, 20, 6);
                    const fireOffset = Math.sin(Date.now() / 100) * 2;
                    ctx.fillStyle = '#f86848';
                    ctx.beginPath();
                    ctx.moveTo(px + 16, py + 6 + fireOffset);
                    ctx.lineTo(px + 22, py + 18);
                    ctx.lineTo(px + 10, py + 18);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#f8a848';
                    ctx.beginPath();
                    ctx.moveTo(px + 16, py + 10 + fireOffset);
                    ctx.lineTo(px + 20, py + 18);
                    ctx.lineTo(px + 12, py + 18);
                    ctx.closePath();
                    ctx.fill();
                    break;

                // Vibe Village tiles
                case TILES.EASEL:
                case 60:
                    ctx.fillStyle = '#8b5a2b';
                    ctx.fillRect(px + 8, py + 8, 4, 20);
                    ctx.fillRect(px + 20, py + 8, 4, 20);
                    ctx.fillRect(px + 6, py + 6, 20, 14);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(px + 8, py + 8, 16, 10);
                    ctx.fillStyle = colors.accent;
                    ctx.fillRect(px + 10, py + 10, 6, 6);
                    break;

                case TILES.HAMMOCK:
                case 61:
                    ctx.fillStyle = '#6b4a1b';
                    ctx.fillRect(px + 4, py + 8, 4, 18);
                    ctx.fillRect(px + 24, py + 8, 4, 18);
                    ctx.fillStyle = colors.accent;
                    ctx.beginPath();
                    ctx.moveTo(px + 6, py + 10);
                    ctx.quadraticCurveTo(px + 16, py + 20, px + 26, py + 10);
                    ctx.lineTo(px + 26, py + 14);
                    ctx.quadraticCurveTo(px + 16, py + 24, px + 6, py + 14);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case TILES.FLOWER:
                case 62:
                    ctx.fillStyle = '#3d7a2d';
                    ctx.fillRect(px + 14, py + 16, 4, 12);
                    ctx.fillStyle = colors.accent;
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.arc(px + 16 + Math.cos(angle) * 6, py + 12 + Math.sin(angle) * 6, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(px + 16, py + 12, 4, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case TILES.LANTERN:
                case 63:
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(px + 12, py + 4, 8, 4);
                    ctx.fillRect(px + 14, py + 8, 4, 16);
                    const glowAlpha = 0.3 + Math.sin(Date.now() / 300) * 0.2;
                    ctx.fillStyle = `rgba(255, 200, 100, ${glowAlpha})`;
                    ctx.beginPath();
                    ctx.arc(px + 16, py + 16, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffcc66';
                    ctx.fillRect(px + 10, py + 10, 12, 14);
                    break;

                // Agent Forge tiles
                case TILES.FURNACE:
                case 20:
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(px + 4, py + 8, 24, 22);
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(px + 8, py + 14, 16, 12);
                    const fireGlow = Math.sin(Date.now() / 150) * 0.3 + 0.7;
                    ctx.fillStyle = `rgba(255, 100, 50, ${fireGlow})`;
                    ctx.fillRect(px + 10, py + 16, 12, 8);
                    break;

                case TILES.GEAR:
                case 21:
                    const gearRotation = Date.now() / 1000;
                    ctx.save();
                    ctx.translate(px + 16, py + 16);
                    ctx.rotate(gearRotation);
                    ctx.fillStyle = '#6a6a7a';
                    for (let i = 0; i < 8; i++) {
                        ctx.fillRect(-3, -12, 6, 8);
                        ctx.rotate(Math.PI / 4);
                    }
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = colors.grass;
                    ctx.beginPath();
                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    break;

                case TILES.PIPE:
                case 22:
                    ctx.fillStyle = '#5a5a6a';
                    ctx.fillRect(px + 2, py + 12, 28, 8);
                    ctx.fillStyle = '#4a4a5a';
                    ctx.fillRect(px + 2, py + 14, 28, 4);
                    // Steam puffs
                    if (Math.random() > 0.95) {
                        ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
                        ctx.beginPath();
                        ctx.arc(px + 16, py + 8, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;

                case TILES.CONVEYOR:
                case 23:
                    ctx.fillStyle = '#3a3a4a';
                    ctx.fillRect(px + 2, py + 10, 28, 12);
                    const conveyorOffset = (Date.now() / 100) % 8;
                    ctx.fillStyle = '#5a5a6a';
                    for (let i = -1; i < 5; i++) {
                        ctx.fillRect(px + 4 + i * 8 - conveyorOffset, py + 12, 4, 8);
                    }
                    break;

                // Research Spire tiles
                case TILES.TERMINAL:
                case 30:
                    ctx.fillStyle = '#2a3a4a';
                    ctx.fillRect(px + 4, py + 8, 24, 20);
                    ctx.fillStyle = '#1a2a3a';
                    ctx.fillRect(px + 6, py + 10, 20, 12);
                    // Screen glow
                    ctx.fillStyle = colors.accent;
                    ctx.fillRect(px + 8, py + 12, 16, 8);
                    // Blinking cursor
                    if (Math.floor(Date.now() / 500) % 2 === 0) {
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(px + 10, py + 14, 2, 4);
                    }
                    break;

                case TILES.CRYSTAL:
                case 31:
                    const crystalGlow = 0.5 + Math.sin(Date.now() / 400) * 0.3;
                    ctx.fillStyle = `rgba(64, 192, 255, ${crystalGlow})`;
                    ctx.beginPath();
                    ctx.moveTo(px + 16, py + 4);
                    ctx.lineTo(px + 24, py + 20);
                    ctx.lineTo(px + 8, py + 20);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = colors.accent;
                    ctx.beginPath();
                    ctx.moveTo(px + 16, py + 8);
                    ctx.lineTo(px + 20, py + 18);
                    ctx.lineTo(px + 12, py + 18);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case TILES.BOOKSHELF:
                case 32:
                    ctx.fillStyle = '#5a4a3a';
                    ctx.fillRect(px + 4, py + 4, 24, 26);
                    // Books
                    const bookColors = ['#a04040', '#4040a0', '#40a040', '#a0a040'];
                    for (let row = 0; row < 3; row++) {
                        for (let col = 0; col < 4; col++) {
                            ctx.fillStyle = bookColors[(row + col) % 4];
                            ctx.fillRect(px + 6 + col * 5, py + 6 + row * 8, 4, 6);
                        }
                    }
                    break;

                case TILES.HOLOGRAM:
                case 33:
                    ctx.fillStyle = '#2a2a4a';
                    ctx.fillRect(px + 8, py + 20, 16, 8);
                    // Holographic projection
                    const holoAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.2;
                    ctx.fillStyle = `rgba(64, 192, 255, ${holoAlpha})`;
                    ctx.beginPath();
                    ctx.moveTo(px + 16, py + 4);
                    ctx.lineTo(px + 24, py + 18);
                    ctx.lineTo(px + 8, py + 18);
                    ctx.closePath();
                    ctx.fill();
                    break;

                // Builder's Guild tiles
                case TILES.WORKBENCH:
                case 40:
                    ctx.fillStyle = '#8b6b4b';
                    ctx.fillRect(px + 2, py + 12, 28, 4);
                    ctx.fillStyle = '#6b4a2b';
                    ctx.fillRect(px + 4, py + 16, 4, 12);
                    ctx.fillRect(px + 24, py + 16, 4, 12);
                    // Tools on bench
                    ctx.fillStyle = '#a0a0a0';
                    ctx.fillRect(px + 8, py + 8, 3, 6);
                    ctx.fillRect(px + 14, py + 6, 8, 4);
                    break;

                case TILES.ANVIL:
                case 41:
                    ctx.fillStyle = '#4a4a5a';
                    ctx.fillRect(px + 6, py + 16, 20, 12);
                    ctx.fillRect(px + 4, py + 8, 24, 10);
                    ctx.fillStyle = '#3a3a4a';
                    ctx.fillRect(px + 10, py + 4, 12, 6);
                    break;

                case TILES.TOOLRACK:
                case 42:
                    ctx.fillStyle = '#6b4a2b';
                    ctx.fillRect(px + 4, py + 4, 24, 4);
                    ctx.fillRect(px + 4, py + 14, 24, 4);
                    // Hanging tools
                    ctx.fillStyle = '#a0a0a0';
                    ctx.fillRect(px + 8, py + 8, 2, 10);
                    ctx.fillRect(px + 14, py + 8, 4, 12);
                    ctx.fillRect(px + 22, py + 8, 2, 8);
                    break;

                case TILES.CRATE:
                case 43:
                    ctx.fillStyle = '#8b6b4b';
                    ctx.fillRect(px + 6, py + 10, 20, 18);
                    ctx.fillStyle = '#6b4a2b';
                    ctx.fillRect(px + 6, py + 10, 20, 3);
                    ctx.fillRect(px + 14, py + 10, 4, 18);
                    break;

                // Consulting Keep tiles
                case TILES.CASTLE_WALL:
                case 50:
                    ctx.fillStyle = '#5a5a5a';
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    ctx.fillStyle = '#4a4a4a';
                    ctx.fillRect(px + 2, py + 2, 12, 12);
                    ctx.fillRect(px + 18, py + 2, 12, 12);
                    ctx.fillRect(px + 2, py + 18, 12, 12);
                    ctx.fillRect(px + 18, py + 18, 12, 12);
                    break;

                case TILES.TOWER:
                case 51:
                    ctx.fillStyle = '#6a6a6a';
                    ctx.fillRect(px + 6, py + 8, 20, 22);
                    ctx.fillStyle = '#5a5a5a';
                    // Battlements
                    ctx.fillRect(px + 4, py + 4, 6, 6);
                    ctx.fillRect(px + 14, py + 4, 6, 6);
                    ctx.fillRect(px + 24, py + 4, 6, 6);
                    // Window
                    ctx.fillStyle = '#ffcc66';
                    ctx.fillRect(px + 12, py + 14, 8, 6);
                    break;

                case TILES.BANNER:
                case 52:
                    ctx.fillStyle = '#6b4a2b';
                    ctx.fillRect(px + 14, py + 4, 4, 24);
                    ctx.fillStyle = colors.accent;
                    ctx.beginPath();
                    ctx.moveTo(px + 18, py + 6);
                    ctx.lineTo(px + 28, py + 12);
                    ctx.lineTo(px + 18, py + 18);
                    ctx.closePath();
                    ctx.fill();
                    break;

                case TILES.THRONE:
                case 53:
                    ctx.fillStyle = '#8b6b4b';
                    ctx.fillRect(px + 8, py + 8, 16, 4);
                    ctx.fillRect(px + 10, py + 4, 12, 6);
                    ctx.fillRect(px + 10, py + 12, 4, 16);
                    ctx.fillRect(px + 18, py + 12, 4, 16);
                    ctx.fillStyle = colors.accent;
                    ctx.fillRect(px + 12, py + 14, 8, 6);
                    // Crown decoration
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(px + 14, py + 2, 4, 4);
                    break;

                // Hub-specific tiles
                case TILES.HUB_STATUE:
                case 70:
                    ctx.fillStyle = '#8a8a9a';
                    ctx.fillRect(px + 10, py + 20, 12, 10);
                    ctx.fillRect(px + 12, py + 8, 8, 14);
                    ctx.beginPath();
                    ctx.arc(px + 16, py + 6, 5, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case TILES.HUB_FOUNTAIN:
                case 71:
                    ctx.fillStyle = '#6a6a7a';
                    ctx.beginPath();
                    ctx.arc(px + 16, py + 20, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#5b8cbe';
                    ctx.beginPath();
                    ctx.arc(px + 16, py + 20, 8, 0, Math.PI * 2);
                    ctx.fill();
                    // Water spout
                    const waterHeight = 4 + Math.sin(Date.now() / 200) * 2;
                    ctx.fillStyle = '#7bacde';
                    ctx.fillRect(px + 14, py + 12 - waterHeight, 4, waterHeight);
                    break;

                case TILES.SIGNPOST:
                case 72:
                    ctx.fillStyle = '#6b4a2b';
                    ctx.fillRect(px + 14, py + 12, 4, 18);
                    ctx.fillStyle = '#8b6b4b';
                    ctx.fillRect(px + 4, py + 8, 24, 6);
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '8px Courier';
                    ctx.fillText('CAMP', px + 7, py + 13);
                    break;

                default:
                    // Unknown tile - just grass
                    break;
            }
        }

        function drawPlayer() {
            const px = gameState.player.x * TILE_SIZE;
            const py = gameState.player.y * TILE_SIZE;
            const dir = gameState.player.dir;

            // Body
            ctx.fillStyle = '#e05038';
            ctx.fillRect(px + 8, py + 12, 16, 16);

            // Head
            ctx.fillStyle = '#fcd8b4';
            ctx.fillRect(px + 10, py + 4, 12, 10);

            // Hair
            ctx.fillStyle = '#4a3020';
            ctx.fillRect(px + 10, py + 2, 12, 4);

            // Eyes based on direction
            ctx.fillStyle = '#202020';
            if (dir === DIR.DOWN) {
                ctx.fillRect(px + 12, py + 8, 2, 2);
                ctx.fillRect(px + 18, py + 8, 2, 2);
            } else if (dir === DIR.LEFT) {
                ctx.fillRect(px + 11, py + 8, 2, 2);
            } else if (dir === DIR.RIGHT) {
                ctx.fillRect(px + 19, py + 8, 2, 2);
            }

            // Legs with animation
            ctx.fillStyle = '#4a4a6a';
            const legOffset = gameState.player.moving ? Math.sin(gameState.animTimer / 80) * 2 : 0;
            ctx.fillRect(px + 10, py + 26, 4, 6 + legOffset);
            ctx.fillRect(px + 18, py + 26, 4, 6 - legOffset);
        }

        function drawNPC(speaker) {
            const px = speaker.x * TILE_SIZE;
            const py = speaker.y * TILE_SIZE;
            const collected = gameState.collectedInsights.has(speaker.id);

            // Body
            ctx.fillStyle = speaker.color;
            ctx.fillRect(px + 8, py + 12, 16, 16);

            // Head
            ctx.fillStyle = '#fcd8b4';
            ctx.fillRect(px + 10, py + 4, 12, 10);

            // Hair
            ctx.fillStyle = collected ? '#ffd700' : '#4a4a4a';
            ctx.fillRect(px + 10, py + 2, 12, 4);

            // Eyes
            ctx.fillStyle = '#202020';
            ctx.fillRect(px + 12, py + 8, 2, 2);
            ctx.fillRect(px + 18, py + 8, 2, 2);

            // Indicator
            if (!collected) {
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 16px Courier New';
                ctx.fillText('!', px + 13, py);
            } else {
                ctx.fillStyle = '#ffd700';
                ctx.font = '12px Courier New';
                ctx.fillText('', px + 12, py);
            }
        }

        function getCurrentWorldSpeakers() {
            return SPEAKERS[gameState.currentWorld] || [];
        }

        function renderWorld(worldId, offsetX = 0, offsetY = 0, includePlayer = true) {
            const colors = getWorldColors(worldId);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.fillStyle = colors.grass;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            const map = MAPS[worldId];
            if (!map) {
                ctx.restore();
                return;
            }

            // Draw map
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    drawTile(x, y, getTileAt(worldId, x, y), worldId);
                }
            }

            // Draw NPCs
            const speakers = SPEAKERS[worldId] || [];
            for (const speaker of speakers) {
                if (speaker.x !== gameState.player.x || speaker.y !== gameState.player.y || worldId !== gameState.currentWorld) {
                    drawNPC(speaker);
                }
            }

            if (includePlayer) {
                drawPlayer();
            }

            ctx.restore();
        }

        function renderWorldTransition() {
            const t = gameState.transition;
            let fromX = 0, fromY = 0, toX = 0, toY = 0;

            switch (t.direction) {
                case 'north':
                    fromY = t.progress;
                    toY = -CANVAS_HEIGHT + t.progress;
                    break;
                case 'south':
                    fromY = -t.progress;
                    toY = CANVAS_HEIGHT - t.progress;
                    break;
                case 'west':
                    fromX = t.progress;
                    toX = -CANVAS_WIDTH + t.progress;
                    break;
                case 'east':
                    fromX = -t.progress;
                    toX = CANVAS_WIDTH - t.progress;
                    break;
            }

            renderWorld(t.from, fromX, fromY, true);
            renderWorld(t.to, toX, toY, false);
        }

        function render() {
            if (gameState.transition.active) {
                renderWorldTransition();
                return;
            }

            renderWorld(gameState.currentWorld, 0, 0, true);

        }

        // ============================================
        // ZOOM/WORLD MAP RENDERING
        // ============================================
        function renderZoomMap() {
            const worldOrder = ['consulting', 'research', 'vibe', 'hub', 'agent', 'builder'];
            // Layout: Consulting north of Research, Vibe-Hub-Agent in middle row, Builder south of Hub
            const worldPositions = {
                consulting: { x: 225, y: 0 },  // Top center
                research: { x: 225, y: 100 },  // Below consulting
                vibe: { x: 0, y: 200 },        // West of hub
                hub: { x: 225, y: 200 },       // Center
                agent: { x: 450, y: 200 },     // East of hub
                builder: { x: 225, y: 300 }    // South of hub
            };

            zoomCtx.fillStyle = '#1a1a2e';
            zoomCtx.fillRect(0, 0, 600, 400);

            // Draw each world as a mini-map
            for (const worldId of worldOrder) {
                const pos = worldPositions[worldId];
                const world = WORLDS[worldId];
                const isCurrentWorld = worldId === gameState.currentWorld;

                // World background
                zoomCtx.fillStyle = world.bgColor;
                zoomCtx.fillRect(pos.x, pos.y, 150, 100);

                // Border (highlighted if current)
                zoomCtx.strokeStyle = isCurrentWorld ? '#ffffff' : world.accentColor;
                zoomCtx.lineWidth = isCurrentWorld ? 4 : 2;
                zoomCtx.strokeRect(pos.x, pos.y, 150, 100);

                // World icon and name
                drawWorldIcon(zoomCtx, world.icon, pos.x + 10, pos.y + 6, 16, world.accentColor);
                zoomCtx.fillStyle = '#ffffff';
                zoomCtx.font = 'bold 12px Courier New';
                zoomCtx.textAlign = 'center';
                zoomCtx.fillText(world.name, pos.x + 85, pos.y + 20);

                // Progress indicator
                const speakers = SPEAKERS[worldId] || [];
                const collected = speakers.filter(s => gameState.collectedInsights.has(s.id)).length;
                const total = speakers.length;

                zoomCtx.font = '10px Courier New';
                if (total > 0) {
                    zoomCtx.fillStyle = collected === total ? '#7ec850' : '#f8a848';
                    zoomCtx.fillText(`${collected}/${total} insights`, pos.x + 75, pos.y + 40);
                }

                // Draw mini NPCs
                const speakerList = SPEAKERS[worldId] || [];
                for (const speaker of speakerList) {
                    const miniX = pos.x + 20 + (speaker.x / MAP_WIDTH) * 110;
                    const miniY = pos.y + 50 + (speaker.y / MAP_HEIGHT) * 40;
                    const isCollected = gameState.collectedInsights.has(speaker.id);

                    zoomCtx.fillStyle = isCollected ? '#ffd700' : speaker.color;
                    zoomCtx.beginPath();
                    zoomCtx.arc(miniX, miniY, 4, 0, Math.PI * 2);
                    zoomCtx.fill();
                }

                // Player marker if in this world
                if (isCurrentWorld) {
                    const playerX = pos.x + 20 + (gameState.player.x / MAP_WIDTH) * 110;
                    const playerY = pos.y + 50 + (gameState.player.y / MAP_HEIGHT) * 40;
                    zoomCtx.fillStyle = '#ff4444';
                    zoomCtx.beginPath();
                    zoomCtx.arc(playerX, playerY, 6, 0, Math.PI * 2);
                    zoomCtx.fill();
                    zoomCtx.fillStyle = '#ffffff';
                    zoomCtx.beginPath();
                    zoomCtx.arc(playerX, playerY, 3, 0, Math.PI * 2);
                    zoomCtx.fill();
                }
            }

            zoomCtx.textAlign = 'left';
        }

        // Handle clicks on zoom map for teleportation
        zoomCanvas.addEventListener('click', (e) => {
            const rect = zoomCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const worldPositions = {
                consulting: { x: 225, y: 0 },
                research: { x: 225, y: 100 },
                vibe: { x: 0, y: 200 },
                hub: { x: 225, y: 200 },
                agent: { x: 450, y: 200 },
                builder: { x: 225, y: 300 }
            };

            for (const [worldId, pos] of Object.entries(worldPositions)) {
                if (x >= pos.x && x <= pos.x + 150 && y >= pos.y && y <= pos.y + 100) {
                    if (worldId !== gameState.currentWorld) {
                        teleportToWorld(worldId);
                    }
                    toggleZoomMap();
                    return;
                }
            }
        });

        // ============================================
        // GAME LOGIC
        // ============================================
        function applyWorldChange(worldId, position = null, dir = null) {
            if (!WORLDS[worldId]) return;

            gameState.currentWorld = worldId;
            const spawn = position || SPAWN_POINTS[worldId];
            gameState.player.x = spawn.x;
            gameState.player.y = spawn.y;
            if (dir !== null) gameState.player.dir = dir;
            gameState.player.moving = false;
            gameState.moveTimer = 0;

            updateHUD();

            // Restart music with new theme
            if (musicPlaying) {
                stopMusic();
                setTimeout(startMusic, 100);
            }
        }

        function teleportToWorld(worldId) {
            if (!WORLDS[worldId]) return;

            playPortalSound();
            applyWorldChange(worldId, null, DIR.DOWN);
        }

        function getExitAt(worldId, x, y) {
            const neighbors = WORLD_NEIGHBORS[worldId];
            if (!neighbors) return null;

            for (const [direction, destination] of Object.entries(neighbors)) {
                if (!destination) continue;
                const zone = EXIT_ZONES[direction];
                if (!zone) continue;
                if (zone.some(pos => pos.x === x && pos.y === y)) {
                    return { direction, destination };
                }
            }

            return null;
        }

        function isExitApproachTile(worldId, x, y) {
            const neighbors = WORLD_NEIGHBORS[worldId];
            if (!neighbors) return false;

            if (neighbors.north && (x === 9 || x === 10) && y === 1) return true;
            if (neighbors.south && (x === 9 || x === 10) && y === 13) return true;
            if (neighbors.west && x === 1 && (y === 7 || y === 8)) return true;
            if (neighbors.east && x === 18 && (y === 7 || y === 8)) return true;

            return false;
        }

        function getTileAt(worldId, x, y) {
            const map = MAPS[worldId];
            if (!map) return TILES.TREE;
            const exit = getExitAt(worldId, x, y);
            if (exit || isExitApproachTile(worldId, x, y)) return TILES.PATH;
            const tile = map[y][x];
            return tile === TILES.PORTAL ? TILES.PATH : tile;
        }

        function getEntryPosition(direction, x, y) {
            switch (direction) {
                case 'north':
                    return { x, y: MAP_HEIGHT - 2 };
                case 'south':
                    return { x, y: 1 };
                case 'west':
                    return { x: MAP_WIDTH - 2, y };
                case 'east':
                    return { x: 1, y };
                default:
                    return { x, y };
            }
        }

        function startWorldTransition(direction, destination) {
            if (!destination || gameState.transition.active) return;

            const entry = getEntryPosition(direction, gameState.player.x, gameState.player.y);
            gameState.transition = {
                active: true,
                direction,
                from: gameState.currentWorld,
                to: destination,
                progress: 0,
                targetX: entry.x,
                targetY: entry.y
            };

            gameState.dialogue.active = false;
            gameState.player.dir = {
                north: DIR.UP, south: DIR.DOWN, west: DIR.LEFT, east: DIR.RIGHT
            }[direction] || gameState.player.dir;

            playPortalSound();
        }

        function updateWorldTransition(dt) {
            const t = gameState.transition;
            const maxDistance = (t.direction === 'north' || t.direction === 'south') ? CANVAS_HEIGHT : CANVAS_WIDTH;
            t.progress = Math.min(maxDistance, t.progress + dt * TRANSITION_SPEED);
            if (t.progress >= maxDistance) {
                finishWorldTransition();
            }
        }

        function finishWorldTransition() {
            const t = gameState.transition;
            applyWorldChange(t.to, { x: t.targetX, y: t.targetY });
            gameState.transition = { active: false, direction: null, from: null, to: null, progress: 0, targetX: 0, targetY: 0 };
        }

        function isWalkable(x, y) {
            if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return false;

            const tile = getTileAt(gameState.currentWorld, x, y);

            // Walkable tiles
            const walkableTiles = [TILES.GRASS, TILES.PATH, TILES.PORTAL,
                TILES.FLOWER, 62, // Flower decoration
                TILES.SIGNPOST, 72 // Signpost
            ];

            if (!walkableTiles.includes(tile)) return false;

            // Check for NPC collision
            const speakers = getCurrentWorldSpeakers();
            for (const speaker of speakers) {
                if (speaker.x === x && speaker.y === y) return false;
            }

            return true;
        }

        function getFacingNPC() {
            let checkX = gameState.player.x;
            let checkY = gameState.player.y;

            switch (gameState.player.dir) {
                case DIR.UP: checkY--; break;
                case DIR.DOWN: checkY++; break;
                case DIR.LEFT: checkX--; break;
                case DIR.RIGHT: checkX++; break;
            }

            const speakers = getCurrentWorldSpeakers();
            return speakers.find(s => s.x === checkX && s.y === checkY);
        }

        function startDialogue(speaker) {
            const collected = gameState.collectedInsights.has(speaker.id);

            gameState.dialogue = {
                active: true,
                speaker: speaker,
                lines: collected ? [speaker.followUp] : [speaker.greeting, speaker.insight],
                currentLine: 0,
                charIndex: 0,
                fullText: '',
                displayText: '',
                isTyping: true
            };

            gameState.dialogue.fullText = gameState.dialogue.lines[0];

            dialogueSpeaker.textContent = `${speaker.name} - ${speaker.org}`;
            const videoInfo = SPEAKER_VIDEO_TIMESTAMPS[speaker.id];
            if (videoInfo) {
                dialogueLink.href = `${VIDEO_URL}&t=${videoInfo.t}`;
                dialogueLink.textContent = `Watch video (${videoInfo.label})`;
                dialogueLink.style.display = 'inline-block';
            } else {
                dialogueLink.href = '#';
                dialogueLink.textContent = '';
                dialogueLink.style.display = 'none';
            }
            dialogueText.textContent = '';
            dialogueBox.classList.remove('hidden');

            playTalkStart();
        }

        function advanceDialogue() {
            const d = gameState.dialogue;

            if (d.isTyping) {
                d.displayText = d.fullText;
                d.isTyping = false;
                dialogueText.textContent = d.displayText;
                playDialogueAdvance();
                return;
            }

            d.currentLine++;

            if (d.currentLine >= d.lines.length) {
                if (!gameState.collectedInsights.has(d.speaker.id)) {
                    gameState.collectedInsights.add(d.speaker.id);
                    updateHUD();
                    playInsightCollected();

                    if (gameState.collectedInsights.size >= TOTAL_INSIGHTS) {
                        setTimeout(() => {
                            gameState.screen = 'victory';
                            victoryScreen.classList.remove('hidden');
                            hud.classList.add('hidden');
                            stopMusic();
                            playVictoryFanfare();
                        }, 500);
                    }
                }

                d.active = false;
                dialogueBox.classList.add('hidden');
                dialogueLink.style.display = 'none';
                playDialogueAdvance();
                return;
            }

            d.fullText = d.lines[d.currentLine];
            d.displayText = '';
            d.charIndex = 0;
            d.isTyping = true;
            playDialogueAdvance();
        }

        function updateDialogueTyping(dt) {
            const d = gameState.dialogue;
            if (!d.active || !d.isTyping) return;

            gameState.typeTimer += dt;

            if (gameState.typeTimer >= 30) {
                gameState.typeTimer = 0;

                if (d.charIndex < d.fullText.length) {
                    d.charIndex++;
                    d.displayText = d.fullText.substring(0, d.charIndex);
                    dialogueText.textContent = d.displayText;

                    const char = d.fullText[d.charIndex - 1];
                    if (char !== ' ' && d.charIndex % 2 === 0) {
                        playTextBlip();
                    }
                } else {
                    d.isTyping = false;
                }
            }
        }

        function updateHUD() {
            insightCounter.textContent = `Insights: ${gameState.collectedInsights.size}/${TOTAL_INSIGHTS}`;
            worldNameDisplay.textContent = WORLDS[gameState.currentWorld].name;
            updateWorldInventory();
        }

        function updateJournal(searchQuery = '') {
            journalEntries.innerHTML = '';
            const query = searchQuery.toLowerCase().trim();
            let totalMatchCount = 0;

            const worldOrder = ['hub', 'vibe', 'agent', 'research', 'builder', 'consulting'];

            for (const worldId of worldOrder) {
                const speakers = SPEAKERS[worldId] || [];
                if (speakers.length === 0) continue;

                const world = WORLDS[worldId];
                let worldMatchCount = 0;
                let worldHtml = '';

                for (const speaker of speakers) {
                    const collected = gameState.collectedInsights.has(speaker.id);

                    const searchableText = [
                        speaker.name,
                        speaker.org,
                        collected ? speaker.insight : '',
                        collected ? speaker.greeting : ''
                    ].join(' ').toLowerCase();

                    const matches = query === '' || searchableText.includes(query);

                    if (matches) {
                        worldMatchCount++;
                        totalMatchCount++;
                    }

                    const highlight = (text) => {
                        if (query === '' || !matches) return text;
                        const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                        return text.replace(regex, '<span class="highlight">$1</span>');
                    };

                    const displayName = highlight(speaker.name);
                    const displayOrg = highlight(speaker.org);
                    const displayInsight = collected ? highlight(speaker.insight) : '??? (Talk to this speaker)';
                    const videoInfo = SPEAKER_VIDEO_TIMESTAMPS[speaker.id];
                    const videoLink = videoInfo
                        ? `<a class="speaker-link" href="${VIDEO_URL}&t=${videoInfo.t}" target="_blank" rel="noopener noreferrer">Watch video (${videoInfo.label})</a>`
                        : '';

                    const hiddenClass = matches ? '' : ' hidden-by-search';
                    const collectedClass = collected ? ' collected' : '';

                    worldHtml += `
                        <div class="journal-entry${collectedClass}${hiddenClass}">
                            <div class="speaker-name">
                                ${displayName}
                                ${collected ? '<span class="checkmark"></span>' : ''}
                            </div>
                            <div class="speaker-org">${displayOrg}</div>
                            ${videoLink ? `<div>${videoLink}</div>` : ''}
                            <div class="${collected ? 'insight-text' : 'not-collected'}">
                                ${collected ? `"${displayInsight}"` : displayInsight}
                            </div>
                        </div>
                    `;
                }

                // Only show world section if it has matches (or no search query)
                if (query === '' || worldMatchCount > 0) {
                    const collectedCount = speakers.filter(s => gameState.collectedInsights.has(s.id)).length;
                    const iconDataUrl = getWorldIconDataURL(worldId, 24);
                    const isComplete = collectedCount === speakers.length;
                    const sectionHtml = `
                        <div class="journal-world-section">
                            <div class="journal-world-header" style="background: ${world.bgColor}; border: 2px solid ${world.accentColor};">
                                <span class="world-title">
                                    <img class="world-icon" src="${iconDataUrl}" alt="${world.name} icon">
                                    ${world.name}
                                </span>
                                <span class="world-progress">
                                    ${isComplete ? '<span style="color: #7ec850;"></span>' : ''}
                                    ${collectedCount}/${speakers.length}
                                </span>
                            </div>
                            ${worldHtml}
                        </div>
                    `;
                    journalEntries.innerHTML += sectionHtml;
                }
            }

            const resultsCount = document.getElementById('search-results-count');
            if (query) {
                resultsCount.textContent = `${totalMatchCount}/${TOTAL_INSIGHTS}`;
            } else {
                resultsCount.textContent = '';
            }
        }

        function setupJournalSearch() {
            const searchInput = document.getElementById('journal-search');
            searchInput.addEventListener('input', (e) => {
                updateJournal(e.target.value);
            });

            searchInput.addEventListener('keydown', (e) => {
                e.stopPropagation();
                if (e.key === 'Escape') {
                    searchInput.value = '';
                    updateJournal('');
                    searchInput.blur();
                }
            });
        }

        function handleMovement(dt) {
            if (gameState.transition.active) return;
            if (gameState.dialogue.active) return;

            gameState.moveTimer += dt;

            if (gameState.moveTimer < 120) return;

            let newX = gameState.player.x;
            let newY = gameState.player.y;
            let moved = false;

            if (keys.up) {
                newY--;
                gameState.player.dir = DIR.UP;
                moved = true;
            } else if (keys.down) {
                newY++;
                gameState.player.dir = DIR.DOWN;
                moved = true;
            } else if (keys.left) {
                newX--;
                gameState.player.dir = DIR.LEFT;
                moved = true;
            } else if (keys.right) {
                newX++;
                gameState.player.dir = DIR.RIGHT;
                moved = true;
            }

            if (moved && isWalkable(newX, newY)) {
                gameState.player.x = newX;
                gameState.player.y = newY;
                gameState.player.moving = true;
                gameState.moveTimer = 0;
                playFootstep();

                const exit = getExitAt(gameState.currentWorld, gameState.player.x, gameState.player.y);
                if (exit) {
                    startWorldTransition(exit.direction, exit.destination);
                }

            } else {
                gameState.player.moving = false;
            }
        }

        // ============================================
        // INPUT HANDLING
        // ============================================
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    keys.up = true; e.preventDefault(); break;
                case 'ArrowDown': case 's': case 'S':
                    keys.down = true; e.preventDefault(); break;
                case 'ArrowLeft': case 'a': case 'A':
                    keys.left = true; e.preventDefault(); break;
                case 'ArrowRight': case 'd': case 'D':
                    keys.right = true; e.preventDefault(); break;
                case ' ':
                    if (!keys.space) { keys.space = true; handleSpacePress(); }
                    e.preventDefault(); break;
                case 'j': case 'J': case 'Tab':
                    if (!keys.j) { keys.j = true; handleJournalToggle(); }
                    e.preventDefault(); break;
                case 'Escape':
                    keys.esc = true; handleEscape(); e.preventDefault(); break;
                case 'm': case 'M':
                    if (!keys.m) { keys.m = true; toggleSound(); }
                    e.preventDefault(); break;
                case 'z': case 'Z':
                    if (!keys.z) { keys.z = true; toggleZoomMap(); }
                    e.preventDefault(); break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W': keys.up = false; break;
                case 'ArrowDown': case 's': case 'S': keys.down = false; break;
                case 'ArrowLeft': case 'a': case 'A': keys.left = false; break;
                case 'ArrowRight': case 'd': case 'D': keys.right = false; break;
                case ' ': keys.space = false; break;
                case 'j': case 'J': case 'Tab': keys.j = false; break;
                case 'Escape': keys.esc = false; break;
                case 'm': case 'M': keys.m = false; break;
                case 'z': case 'Z': keys.z = false; break;
            }
        });

        function handleSpacePress() {
            initAudio();

            if (gameState.transition.active) return;

            switch (gameState.screen) {
                case 'title':
                    gameState.screen = 'game';
                    titleScreen.classList.add('hidden');
                    hud.classList.remove('hidden');
                    worldInventory.classList.remove('hidden');
                    initWorldInventory();
                    updateHUD();
                    updateWorldInventory();
                    playMenuOpen();
                    startMusic();
                    break;

                case 'game':
                    if (gameState.dialogue.active) {
                        advanceDialogue();
                    } else {
                        const npc = getFacingNPC();
                        if (npc) {
                            startDialogue(npc);
                        }
                    }
                    break;

                case 'journal':
                    gameState.screen = 'game';
                    journalScreen.classList.add('hidden');
                    playMenuClose();
                    break;

                case 'zoom':
                    toggleZoomMap();
                    break;

                case 'victory':
                    stopMusic();
                    playMenuClose();
                    gameState = {
                        screen: 'title',
                        currentWorld: 'hub',
                        player: { x: 9, y: 12, dir: DIR.DOWN, moving: false, animFrame: 0 },
                        transition: { active: false, direction: null, from: null, to: null, progress: 0, targetX: 0, targetY: 0 },
                        collectedInsights: new Set(),
                        dialogue: {
                            active: false, speaker: null, lines: [], currentLine: 0,
                            charIndex: 0, fullText: '', displayText: '', isTyping: false
                        },
                        lastTime: 0, moveTimer: 0, typeTimer: 0, animTimer: 0
                    };
                    victoryScreen.classList.add('hidden');
                    hud.classList.add('hidden');
                    worldInventory.classList.add('hidden');
                    titleScreen.classList.remove('hidden');
                    break;
            }
        }

        function handleJournalToggle() {
            initAudio();

            if (gameState.transition.active) return;

            if (gameState.screen === 'game' && !gameState.dialogue.active) {
                gameState.screen = 'journal';
                const searchInput = document.getElementById('journal-search');
                searchInput.value = '';
                updateJournal('');
                journalScreen.classList.remove('hidden');
                playMenuOpen();
                setTimeout(() => searchInput.focus(), 100);
            } else if (gameState.screen === 'journal') {
                gameState.screen = 'game';
                journalScreen.classList.add('hidden');
                playMenuClose();
            }
        }

        function toggleZoomMap() {
            initAudio();

            if (gameState.transition.active) return;

            if (gameState.screen === 'game' && !gameState.dialogue.active) {
                gameState.screen = 'zoom';
                renderZoomMap();
                zoomOverlay.classList.remove('hidden');
                playMenuOpen();
            } else if (gameState.screen === 'zoom') {
                gameState.screen = 'game';
                zoomOverlay.classList.add('hidden');
                playMenuClose();
            }
        }

        function handleEscape() {
            if (gameState.screen === 'journal') {
                gameState.screen = 'game';
                journalScreen.classList.add('hidden');
                playMenuClose();
            } else if (gameState.screen === 'zoom') {
                gameState.screen = 'game';
                zoomOverlay.classList.add('hidden');
                playMenuClose();
            }
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function update(dt) {
            if (gameState.screen !== 'game') return;

            if (gameState.transition.active) {
                updateWorldTransition(dt);
                return;
            }

            gameState.animTimer += dt;

            handleMovement(dt);
            updateDialogueTyping(dt);

            if (!keys.up && !keys.down && !keys.left && !keys.right) {
                gameState.player.moving = false;
            }
        }

        function gameLoop(timestamp) {
            const dt = timestamp - gameState.lastTime;
            gameState.lastTime = timestamp;

            update(dt);

            if (gameState.screen === 'game') {
                render();
            }

            requestAnimationFrame(gameLoop);
        }

        // Click handler for sound toggle button
        document.getElementById('sound-toggle').addEventListener('click', () => {
            initAudio();
            toggleSound();
        });

        // Initialize journal search
        setupJournalSearch();

        // Start the game
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
